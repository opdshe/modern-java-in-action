# π‘¨π»β€π’» λλ‹¤ ν‘ν„μ‹

## λλ‹¤λ€?
κ²°λ΅ λ¶€ν„° λ§ν•μλ©΄, λλ‹¤κ°€ μλ°” 8 μ΄μ „μ μλ°”λ΅ ν•  μ μ—†μ—λ μΌμ„ ν•  μ μκ² ν•΄μ£Όλ” κ²ƒμ€ μ•„λ‹λ‹¤. λλ‹¤λ” μ‰½κ² λ§ν•μλ©΄ μµλ… ν΄λμ¤λ¥Ό μΆ€ λ” κ°„κ²°ν• μ½”λ“λ΅ μ‘μ„±ν• κ²ƒμ΄λ‹¤. ν•μ§€λ§ μ΄ 'κ°„κ²°ν•¨' λ•λ¶„μ— μ½”λ“κ°€ μ μ—°ν•΄μ§€κΈ°λ„ ν•λ‹¤. λλ‹¤λ” νΉν **ν•¨μν• μΈν„°νμ΄μ¤**μ™€ ν•¨κ» μ‚¬μ©ν•  λ• νμ„ λ°νν•λ‹¤.  
<br>

## β¨ ν•¨μν• μΈν„°νμ΄μ¤λ€?
ν•¨μν• μΈν„°νμ΄μ¤λ€ **μ •ν™•ν ν•λ‚μ μ¶”μƒ λ©”μ„λ“λ¥Ό μ§€μ •ν•λ” μΈν„°νμ΄μ¤μ΄λ‹¤.** μ—†μ–΄λ„ μ• λκ³ , 2κ° μ΄μƒλ„ μ• λλ‹¤. **μ¤μ§ ν•λ‚μ μ¶”μƒ λ©”μ„λ“λ¥Ό κ°€μ Έμ•Ό ν•λ‹¤.**(μ΄λ•, λ””ν΄νΈ λ©”μ„λ“μ μλ” μ¤‘μ”ν•μ§€ μ•λ‹¤.)
<br>  
**@FunctionalInterfaceλ€**  
@FunctionalInterfaceλ” ν•¨μν• μΈν„°νμ΄μ¤μ„μ„ λ‚νƒ€λ‚΄λ” μ–΄λ…Έν…μ΄μ…μ΄λ‹¤. μ¦‰, @FunctionalInterfaceλ΅ μΈν„°νμ΄μ¤λ¥Ό μ„ μ–Έν–μ§€λ§ μ‹¤μ λ΅ ν•¨μν• μΈν„°νμ΄μ¤κ°€ μ•„λ‹λ©΄(μ¶”μƒ λ©”μ„λ“κ°€ ν•λ‚κ°€ μ•„λ‹λ©΄) μ»΄νμΌ μ—λ¬λ¥Ό λ°μƒμ‹ν‚¨λ‹¤.  
<br>

## ν•¨μν• μΈν„°νμ΄μ¤μ μΆ…λ¥  
### Predicate
```
@FunctionalInterface
public interface Predicate<T> {
  boolean test(T t);
}
```
- **T ν•μ‹μ κ°μ²΄λ¥Ό μΈμλ΅ λ°›μ•„ booleanμ„ λ°ν™ν•λ‹¤**
- **test**λΌλ” μ¶”μƒ λ©”μ„λ“λ¥Ό μ •μ
<br>

### Consumer
```
@FunctionalInterface
public interface Consumer<T> {
  void accept(T t);
}
```
- **T ν•μ‹μ κ°μ²΄λ¥Ό μΈμλ΅ λ°›μ•„ voidλ¥Ό λ°ν™ν•λ‹¤**
- **accept**λΌλ” μ¶”μƒ λ©”μ„λ“λ¥Ό μ •μ
- T ν•μ‹μ κ°μ²΄λ¥Ό μΈμλ΅ λ°›μ•„ μ–΄λ–¤ λ™μ‘μ„ μν–‰ν•κ³  μ‹¶μ„ λ• μ‚¬μ©
<br>

### Function
```
@FunctionalInterface
public interface Function<T, R> {
  R apply(T t);
}
```
- **T ν•μ‹μ κ°μ²΄λ¥Ό μΈμλ΅ λ°›μ•„ Rν•μ‹μ κ°μ²΄λ¥Ό λ°ν™ν•λ‹¤**
- **apply**λΌλ” μ¶”μƒ λ©”μ„λ“λ¥Ό μ •μ
- μ…λ ¥μ„ μ¶λ ¥μΌλ΅ λ§¤ν•‘ν•κ³  μ‹¶μ„ λ• μ‚¬μ©
<br>


### κΈ°λ³Έν• νΉν™” μΈν„°νμ΄μ¤ μ κ³µ
μ λ„¤λ¦­ νλΌλ―Έν„° Tλ” **μ°Έμ΅°ν•(Reference type)** μ—λ§ μ‚¬μ©ν•  μ μλ‹¤. μ¦‰, **κΈ°λ³Έν•(Primitive type)μ—λ” μ‚¬μ©ν•  μ μ—†λ‹¤.** λ‹¤ν–‰νλ„ μλ°”λ” κΈ°λ³Έν•μ„ μ°Έμ΅°ν•μΌλ΅ λ³€ν™ν•λ” κΈ°λ¥μ„ μ κ³µν•λ‹¤. μ΄λ¥Ό **λ°•μ‹±**μ΄λΌκ³  ν•λ‹¤. λ¬Όλ΅ , μ°Έμ΅°ν•μ„ κΈ°λ³Έν•μΌλ΅ λ³€ν™ν•λ” κΈ°λ¥λ„ μ κ³µν•κ³  μ΄λ¥Ό **μ–Έλ°•μ‹±**μ΄λΌκ³  λ¶€λ¥Έλ‹¤. λν•, μλ°”λ” λ°•μ‹±κ³Ό μ–Έλ°•μ‹±μ΄ μλ™μΌλ΅ μ΄λ£¨μ–΄μ§€λ„λ΅ **μ¤ν† λ°•μ‹±**μ„ μ κ³µν•λ‹¤. κ·ΈλΌ λ„λ€μ²΄ λ¬΄μ—‡μ΄ λ¬Έμ μΈκ°€? **λ³€ν™κ³Όμ •μ— λ©”λ¨λ¦¬κ°€ μ‚¬μ©λλ‹¤λ” κ²ƒμ΄ λ¬Έμ μ΄λ‹¤.** μλ¥Όλ“¤μ–΄ μ•„λμ™€ κ°™μ€ μ½”λ“λ¥Ό μ‹¤ν–‰ν•λ©΄ intλ¥Ό Integerμ— λ‹΄κΈ°μ„ν•΄ λ°•μ‹±μ΄ μ§„ν–‰λλ‹¤.
```
List<Integer> list = new ArrayList<>();
for (int i = 300; i < 400; i++) {
  list.add(i);
}
```
μ΄μ²λΌ λ¶ν•„μ”ν• λ°•μ‹± κ³Όμ •μ„ ν”Όν•κΈ° μ„ν•΄ μλ°”λ” κΈ°λ³Έν•μ— νΉν™”λ μΈν„°νμ΄μ¤λ¥Ό μ κ³µν•λ‹¤. **IntPredicate, IntToDoubleFunction, LongSupplier** λ“±μ΄ μ΄μ— ν•΄λ‹Ήλλ‹¤.  
<br>


## μ§€μ—­ λ³€μμ μ μ•½
λλ‹¤μ—μ„λ” **μμ  λ³€μ**(νλΌλ―Έν„°λ΅ λ„κ²¨μ§„ λ³€μκ°€ μ•„λ‹ μ™Έλ¶€μ—μ„ μ •μλ λ³€μ)μ— μ ‘κ·Όμ΄ κ°€λ¥ν•λ‹¤. λ‹¨, λλ‹¤μ—μ„ μ‚¬μ©λ  μ§€μ—­ λ³€μλ” λ…μ‹μ μΌλ΅ finalμ΄ μ„ μ–Έλμ–΄ μμ–΄μ•Ό ν•κ±°λ‚, μ‹¤μ§μ μΌλ΅ **finalλ΅ μ„ μ–Έλ λ³€μμ™€ λ‘κ°™μ΄ μ‚¬μ©λμ–΄μ•Ό ν•λ‹¤.** μ¦‰, μ¬ν• λ‹Ήμ΄ λ¶κ°€λ¥ν•λ‹¤. μλ¥Ό λ“¤μ–΄ μ•„λμ™€ κ°™μ€ μ½”λ“λ” μ»΄νμΌ ν•  μ μ—†λ‹¤.
```
int portNumber = 1337;
Runnable r = () -> System.out.println(portNumber);
portNumber = 31337;
```
<br>

**β¨ μ§€μ—­ λ³€μμ μ μ•½μ΄ ν•„μ”ν• μ΄μ **  

**μΈμ¤ν„΄μ¤ λ³€μλ” ν™**μ— μ €μ¥λλ” λ°λ©΄, **μ§€μ—­ λ³€μλ” μ¤νƒμ— μ €μ¥λλ‹¤** λ©€ν‹° μ¤λ λ“ ν™κ²½μ—μ„ μ‹¤ν–‰ν•  λ• κ° μ¤λ λ“λ” κ°λ³„μ  μ¤νƒμ„ κ°€μ§„λ‹¤. μ΄λ” λ™κΈ°ν™” λ¬Έμ λ¥Ό μ΄λν•  μ μμ–΄μ„ μλ°”μ—μ„λ” λλ‹¤μ—μ„ μμ  λ³€μμ— μ ‘κ·Ό μ‹ μ›λ λ³€μμ— μ ‘κ·Όμ„ ν—μ©ν•λ” κ²ƒμ΄ μ•„λ‹λΌ μμ  μ§€μ—­ λ³€μμ **λ³µμ‚¬λ³Έμ„ μ κ³µν•λ‹¤.** λ”°λΌμ„ λ³µμ‚¬λ³Έμ κ°’μ΄ λ°”λ€μ§€ μ•μ•„μ•Ό ν•λ―€λ΅ μ§€μ—­ λ³€μμ—λ” ν• λ²λ§ κ°’μ„ ν• λ‹Ήν•΄μ•Ό ν•λ‹¤λ” μ μ•½μ΄ μƒκΈ΄ κ²ƒμ΄λ‹¤.  
<br>


## λ©”μ„λ“ μ°Έμ΅°
λ©”μ„λ“ μ°Έμ΅°λ¥Ό μ΄μ©ν•λ©΄ κΈ°μ΅΄μ λ©”μ„λ“ μ •μλ¥Ό μ¬ν™μ©ν•΄μ„ λλ‹¤μ²λΌ μ „λ‹¬ν•  μ μλ‹¤. μ‰½κ² λ§ν•΄ **λ©”μ„λ“ μ°Έμ΅°λ” λλ‹¤μ μ¶•μ•½ν•**μ΄λΌκ³ λ„ ν•  μ μλ‹¤. λ©”μ„λ“ μ°Έμ΅°λ¥Ό μ΄μ©ν•λ©΄ μ΅°κΈ λ” **κ°€λ…μ„±μ„ λ†’μΌ μ μλ‹¤.** μλ¥Ό λ“¤μ–΄, 
```(Apple apple) -> apple.getWeight()``` λ³΄λ‹¤λ” ```Apple::getWeight```κ°€ ν›¨μ”¬ λμ— μ λ“¤μ–΄μ¨λ‹¤. 

### μƒμ„±μ μ°Έμ΅°
μΈμκ°€ μ—†λ” μƒμ„±μλ” Supplierμ— λ‹΄μ„ μ μλ‹¤ (void -> R λ°ν™)  
``` Supplier<Apple> constructor = Apple::new;```  
μΈμκ°€ μλ” μƒμ„±μλ” Functionμ— λ‹΄μ„ μ μλ‹¤. (T -> R λ°ν™)  
``` Function<Integer, Apple> constructor = Apple::new;```  
<br>

#### β¨μƒμ„±μμ— μΈμκ°€ μ—¬λ¬κ°λΌλ©΄?
BiFunction, TriFunctionκ³Ό κ°™μ€ μΈν„°νμ΄μ¤λ¥Ό ν†µν•΄ κµ¬ν„μ΄ κ°€λ¥ν•λ‹¤
```
BiFunction<Color, Integer, Apple> constructor = Apple::new;
```

### μ•μ•„λ‘λ©΄ μΆ‹μ€ κµ¬ν„λ²•
```
static Map<String, Function<Integer, Fruit>> map = new HashMap<>();
static {
  map.put("apple", Apple::new);
  map.put("orange", Orange::new);
  //λ“±λ“±
}

public static Fruit giveMeFruit(String fruit, Integer weight){
  return map.get(fruit.toLowerCase())
            .apply(weight);
}
```
μ²μ λ΄¤μ„ λ• μ΄ν•΄ν•κΈ° μ–΄λ ¤μ› μ§€λ§, ν• λ² μ΄ν•΄ν•κ³  λ‚λ‹ κµ‰μ¥ν μ μ©ν•κ² μ‚¬μ©ν•  μ μμ„ κ²ƒ κ°™λ‹¤λ” μƒκ°μ΄ λ“ λ‹¤. (ex. μ‚¬μ©μμ μ…λ ¥μ— ν•΄λ‹Ήν•λ” μ»¤λ§¨λ“ λ§¤ν•‘)
